#ifndef ML_CHOOSER_H
#define ML_CHOOSER_H

#include <iostream>
#include <fstream>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <string>
#include <queue>
#include <cstring>

#include <sys/types.h>
#include <sys/stat.h>

#include "chooser.h"
#include "move_choice.h"

using namespace std;

namespace myrps
{
class MLChooser : public myrps::Chooser
{
public:
  MLChooser(int rounds_per_match);

  /**
   * Continuously adds moves to the hist_data map, and from
   * there uses the map and functions GetMostLikelyMove and
   * GetWinningMove to guess it's move. Defaults to random if
   * the round count is < n / 2.
   */
  MoveChoice DecideMove(MoveChoice player_move);


  /**
   * Returns a map which is empty if there is no csv file
   * or returns a map populated by ReadHistData()
   */
  unordered_map<string, int> GetHistData();

  MoveChoice GetPredictedMove(MoveChoice player_move);

private:
  
  /**
   * Takes last n moves and maps it to its respective frequency.
   */
  unordered_map<string, int> hist_data;

  /**
   * No use yet.
   */
  unordered_map<string, int> old_hist_data;

  /**
   * Number of previous computer/player matchups recorded
   */
  int n; 

  /**
   * Defaults to 20, matches per game.
   */
  int rounds_per_match;

  /**
   * Incremented with each computer/player matchup. Used to determine
   * how many matches were played.
   */
  int round_count;

  /**
   * Queue to keep track of player move and computer move.
   * Layout is |player|computer|player etc...
   * Added to with each player computer matchup.
   */
  queue<MoveChoice> last_n_minus_one_q;

  /**
   * This function tries to make a directory ml_data and
   * returns true if the file exists or was able to be
   * created. Returns false if there was an error making
   * the directory.
   */ 
  bool MLDirectoryExists();
  /**
   * Checks if there is a file called "ml_data_#.csv" in the
   * ml_data directory. Returns a bool based on its findings.
   */
  bool MLFileNExists();

  /**
   * Generates a vector from TokenizeHistoryData and passes it
   * to ParseHistData. From ParseHistData it gets and returns an
   * unordered map
   */
  unordered_map<string, int> ReadHistData();

  /**
   * Reads a csv file and separates each entry by the "," and adds 
   * each entry to a vector of strings, an example being rrrrr:#
   */
  vector<string> TokenizeHistData();
  
  /**
   * Takes a string vector generated by TokenizeHistData and separates
   * the string of moves and frequency. The separated parts are then put 
   * into an unordered map. Moves are mapped to frequency
   */
  unordered_map<string, int> ParseHistData(vector<string> raw_pairs);

  /**
   * Not implemented yet.
   */
  unordered_map<string, int> GenerateHistData();

  /**
   * Calls UpdateHistData no matter the circumstance.
   */ 
  void WriteHistData();

  /**
   * Overwrites the current csv file with the history data. This history
   * data is separated moves and frequency with a ":" and each entry is
   * separated by a comma.
   */ 
  void UpdateHistData();

  /**
   * Takes a parameter which is the player's most likely move and returns
   * the inverse of the move for the computer to choose.
   */
  MoveChoice GetWinningMove(MoveChoice most_likely_move);

  /**
   * This function takes the last n - 1 moves and from there uses 
   * GetPossibleChoices to guess the nth move. From there it sorts the
   * guesses based on frequency, and looks at the guess with the most 
   * frequency to determine as the most likely move.
   */
  MoveChoice GetMostLikelyMove(string last_n_minus_one_moves);

  /**
   * Takes a queue of Move values and converts them to a 
   * string. The size of q is n - 1, and the length of 
   * the result string is n - 1.
   */
  string GetLastNMinusOneMoves(queue<MoveChoice> q);

  /**
   * Adds current move to a string that holds the last n - 1 moves
   * updates entry in history data by 1
   */
  void AddLastNMovesToHist(string last_n_minus_one_moves, MoveChoice curr_move);

  /**
   * Helper function to sort vector of pair<string,int>
   */
  static bool CompareMoveFreq(pair<string, int> &a,
    pair<string, int> &b);

  /**
   * Returns a vector that holds a pair, the last n -1 moves and the possible
   * 5th move. The vector is of size 3, and each sting is the same except for
   * the last char, which is 'r', 'p', or 's'.
   */
  vector<pair<string, int>>
    GetPossibleChoices(string last_n_minus_one_moves);

  /**
   * Takes a permutation and searches the map hist_data for the frequency,
   * adds a new pair to possible_choices with the permutation and frequency.
   * If there is no occurence in the map hist_data, the frequency is 0.
   */
  void
    InsertPossibleChoice(vector<pair<string, int>> &possible_choices,
                          string permutation);

  /**
   * Prints hist_data map contents.
   */
  void PrintHistData();
};
}

#endif
